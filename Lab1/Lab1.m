clc;
close all;
clear all;

% Определяем интенсивность потока Пуассона как функцию
lambda = @(t) exp(-2*t); % (Вариант 2)

% Начальные условия
T0 = 0; % Начальное время
T = 2; % Конечное время
lambda_m = 1; % Вспомогательная интенсивность
N = 10000; % Количество симуляций
m = 50; % Количество интервалов для разбиения временного отрезка
all_events = {}; % Ячейковый массив для хранения всех событий

for i = 1:N
    t_prev = T0; % Предыдущее время
    events = []; % Массив для хранения событий в текущей симуляции
    while true
        alpha_i = rand(); % Массив для хранения событий в текущей симуляции
        t_next = t_prev - log(alpha_i)/lambda_m; % Время следующего события
    
        if t_next > T % Если следующее время больше конечного (выход за пределы интрервала)
            break
        end
    
        y_i = rand(); % Генерация случайного числа для проверки события
        if y_i <= lambda(t_next) % Проверяем, произошло ли событие
            events = [events, t_next]; % Сохраняем событие
        end
        t_prev = t_next; % Обновляем предыдущее время
    end
    all_events{i} = events;% Сохраняем события для текущей симуляции 
end

% -------------------------------- %

% Построить в одном графическом окне на интервале Ω графики интенсивности 
% заданного потока Пуассона, и ее оценки;

% Определяем ширину интервала для гистограммы
delta_t = (T - T0) / m;
X = T0 + (delta_t/2):delta_t:T - (delta_t/2); % Центры интервалов
X_edges = T0:delta_t:T; % Границы интервалов
n_i = zeros(size(X)); % Массив для хранения количества событий для каждого из подинтервалов

% Подсчет количества событий в каждом подинтервале
for i = 1:N
    n = histcounts(all_events{i}, X_edges); % Подсчет событий для текущих данных
    %n = hist(all_events{i}, X);
    n_i = n_i + n; % Суммируем количества событий
end

disp(size(n_i));
disp(length(all_events));

% Вычисляем среднее количество событий
Average_events = n_i / (N * delta_t);

% Построение графика
figure();
hold("on");
plot(X, Average_events); % Экспериментальная интенсивность
plot(X, lambda(X)); % Теоретическая интенсивность
title('График оценки интенсивности потока Пуассона');
xlabel("T");
ylabel("Интенсивность");
legend({'Экспериментальная интенсивность', 'Теоретическая интенсивность'});

% -------------------------------- %

% Построить в одном графическом окне на интервале Ω графики сечения 
% корреляционной функции заданного потока Пуассона и сечения ее оценки, для чего 
% зафиксировать значение одного из временных аргументов в точке, соответствующей 
% максимуму интенсивности;

% Находим индекс элемента в массиве n_i, соответствующего максимальному 
% количеству событий. Этот индекс будет использоваться для фиксации момента 
% времени с максимальной интенсивностью.
max_idx = find(n_i == max(n_i), 1);

% Инициализация матрицы для корреляционных функций (Кол-во реализаций потока N (строки) х
% кол-во карманов (столбцы)). Эта матрица будет использоваться для хранения 
% рассчитанных значений корреляционной функции для каждой реализации и каждого временного сдвига.
correlation_funcs = zeros(N, m);

% Подсчет корреляционных функций (1.7)
for i = 1:N % - цикл по всем реализациям потока
    K_i = histcounts(all_events{i}, [X_edges, T]); % Подсчет количества событий на каждом подинтервале
    for j = 1:m % - цикл по всем подинтервалам, в которых вычисляется корреляционная функция
        % Вызываем функцию get_correlation для вычисления значения корреляционной 
        % функции для текущей реализации.
        correlation_funcs(i, j) = get_correlation(K_i, max_idx, j, delta_t); % Вычисление корреляции
    end
end

% Суммируем значения корреляционной функции по всем реализациям для каждого 
% подинтервала и делим на количество реализаций, получая среднее значение
sum_of_columns = sum(correlation_funcs, 1) / N;

% Построение графиков корреляционной функции
figure();
% Построение эмпирической корреляционной функции
plot(X, sum_of_columns);
hold on;
% Построение теоретической корреляционной функции
plot(X, lambda(X(max_idx)) * lambda(X)); % Теоретическая интенсивность
title('График корреляционной функции');
legend({'Корреляционная функция', 'Теоретическая интенсивность'});
hold off;

% -------------------------------- %

% Построить в одном графическом окне графики распределения числа событий 
% на интервале Ω для заданного потока Пуассона и его оценки; Проверяем, 
% насколько хорошо теоретическая модель (распределение Пуассона) описывает 
% реальные данные симуляции.

% Вычисляем количество элементов (событий) в каждой ячейке матрицы all_events. 
% Результаты сохраняются в векторе event_counts.
event_counts = cellfun(@length, all_events);
max_events = max(event_counts); % Максимальное количество событий среди всех реализаций.
% Вектор bins определяет границы интервалов, в которые будут попадать 
% значения количества событий.
bins = 0:max_events + 1;

hist_counts = histcounts(event_counts, bins);

% Нормируем частоты, чтобы получить вероятности
probabilities = hist_counts / N;

disp(probabilities);

% Построение эмпирического распределения
figure;
bar(bins(1:end-1), probabilities, 0.8, 'FaceAlpha', 0.6, 'FaceColor', 'b'); % Эмпирическая гистограмма
hold on;

% Создаем вектор x_vals для численного интегрирования функции интенсивности lambda.
x_vals = linspace(T0, T, 10000);
% Численно вычисляем интеграл от функции интенсивности lambda на интервале 
% [T0, T]. Результат - среднее количество событий (параметр лямбда для 
% распределения Пуассона).
lambda_theoretical = trapz(x_vals, lambda(x_vals));

poisson_probs = poisspdf(bins(1:end-1), lambda_theoretical); % Poisson probability density function.

% Вывод вероятностей Пуассона
disp("Вероятности Пуассона --->");
disp(poisson_probs);

% Построение теоретического распределения Пуассона
plot(bins(1:end-1), poisson_probs, 'r-o', 'DisplayName', 'Теоретическая прямая');
xlabel('Количество событий');
ylabel('Вероятность');
title('Теоретическое и Экспериментальное распределение Пуассона');
legend('Экспериментальная интенсивность', 'Теоретическая интенсивность');
hold off;

% Сравнивая эмпирическую гистограмму (синие столбцы) с теоретической кривой 
% Пуассона (красная линия), можно оценить, насколько хорошо теоретическое 
% распределение описывает данные симуляции. Если кривые хорошо совпадают, 
% это подтверждает гипотезу о том, что процесс, который моделируется, 
% действительно является пуассоновским.

% -------------------------------- %


% Тест хи-квадрат используется для проверки гипотез о распределении данных. 
% Он позволяет определить, насколько хорошо эмпирическое распределение 
% соответствует теоретическому распределению (Пуассона).

k = 5; % Последний значимый бин

bins_above_k = hist_counts > k; % - бин больше порогового

% Наблюдаемые частоты
empirical_counts = hist_counts(bins_above_k);
% Ожидаемые частоты
poisson_values = poisson_probs * N; 
expected_counts = poisson_values(bins_above_k);
k_new = N - sum(expected_counts);

if sum(~bins_above_k) > 0
    empirical_counts = [empirical_counts, sum(hist_counts(~bins_above_k))]; % суммируем малые эмпирические частоты
    expected_counts = [expected_counts, sum(poisson_values(~bins_above_k))]; % суммируем малые теоретических частоты
end

expected_counts(end) = expected_counts(end) + k_new;
disp(sum(expected_counts));
%expected_counts = expected_counts * (N / sum(expected_counts));

% Расчет статистики хи-квадрат. Вычисляется сумма квадратов разностей между 
% наблюдаемыми и ожидаемыми частотами, деленных на ожидаемые частоты.
chi2 = sum((empirical_counts - expected_counts).^2 ./ expected_counts);

% Степени свободы (число категорий минус 1).  В нашем случае категории - 
% это различные возможные значения числа событий.
df = length(empirical_counts) - 1;

% Критическое значение для alpha = 0.05
alpha = 0.05; % Уровень значимости
chi2_critical = chi2inv(1 - alpha, df); % Критическое значение

% Если вычисленная статистика хи-квадрат больше критического значения, то 
% мы отвергаем нулевую гипотезу о том, что данные следуют распределению Пуассона.

disp(['Статистика хи-квадрат: ', num2str(chi2)]);
disp(['Критическое значение хи-квадрат: ', num2str(chi2_critical)]);

% -------------------------------- %

% Функция для вычисления корреляционной функции между i-м j-м элементами
function corr = get_correlation(n_i, i, j, delta_t)
        % n_i: гистограмма событий для текущей реализации.
        % i: индекс момента максимальной интенсивности.
        % j: номер точки, в которой вычисляется корреляционная функция.
        % delta_t: шаг по времени.
    if i ~= j
        corr = n_i(i) * n_i(j) / (delta_t ^ 2);
    else
        corr = n_i(i) * (n_i(j) - 1) / (delta_t ^ 2);
    end
end
